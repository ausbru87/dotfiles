# ~/.bash_terraform - Terraform and Infrastructure as Code configuration
# Source this from .bashrc for terraform/terragrunt/cloud CLI tooling

# ==============================================================================
# Environment Variables
# ==============================================================================

# Terraform
export TF_PLUGIN_CACHE_DIR="${TF_PLUGIN_CACHE_DIR:-$HOME/.terraform.d/plugin-cache}"
export TF_CLI_ARGS_plan="-parallelism=30"
export TF_CLI_ARGS_apply="-parallelism=30"
export CHECKPOINT_DISABLE=1  # Disable HashiCorp update checks

# Terragrunt
export TERRAGRUNT_DOWNLOAD="${TERRAGRUNT_DOWNLOAD:-$HOME/.terragrunt-cache}"

# AWS
export AWS_PAGER=""  # Disable AWS CLI pager
export AWS_DEFAULT_OUTPUT="json"
export SAM_CLI_TELEMETRY=0

# Azure
export AZURE_CORE_OUTPUT="json"
export AZURE_CORE_NO_COLOR=""

# Google Cloud
export CLOUDSDK_CORE_DISABLE_PROMPTS=1

# OpenShift
export KUBECONFIG="${KUBECONFIG:-$HOME/.kube/config}"

# CDK
export CDK_DEFAULT_ACCOUNT="${CDK_DEFAULT_ACCOUNT:-}"
export CDK_DEFAULT_REGION="${CDK_DEFAULT_REGION:-}"

# Create plugin cache directory
[[ ! -d "$TF_PLUGIN_CACHE_DIR" ]] && mkdir -p "$TF_PLUGIN_CACHE_DIR"

# ==============================================================================
# Terraform Aliases
# ==============================================================================
alias tf='terraform'
alias tfi='terraform init'
alias tfp='terraform plan'
alias tfa='terraform apply'
alias tfaa='terraform apply -auto-approve'
alias tfd='terraform destroy'
alias tfda='terraform destroy -auto-approve'
alias tfo='terraform output'
alias tfoj='terraform output -json'
alias tfs='terraform state'
alias tfsl='terraform state list'
alias tfss='terraform state show'
alias tfv='terraform validate'
alias tff='terraform fmt'
alias tffr='terraform fmt -recursive'
alias tfws='terraform workspace'
alias tfwsl='terraform workspace list'
alias tfwss='terraform workspace select'
alias tfwsn='terraform workspace new'
alias tfc='terraform console'
alias tfg='terraform graph'
alias tfr='terraform refresh'
alias tfim='terraform import'
alias tft='terraform taint'
alias tfut='terraform untaint'
alias tfver='terraform version'
alias tfprov='terraform providers'

# ==============================================================================
# Terragrunt Aliases
# ==============================================================================
alias tg='terragrunt'
alias tgi='terragrunt init'
alias tgp='terragrunt plan'
alias tga='terragrunt apply'
alias tgaa='terragrunt apply -auto-approve'
alias tgd='terragrunt destroy'
alias tgda='terragrunt destroy -auto-approve'
alias tgo='terragrunt output'
alias tgoj='terragrunt output -json'
alias tgv='terragrunt validate'
alias tgf='terragrunt hclfmt'
alias tgra='terragrunt run-all'
alias tgrap='terragrunt run-all plan'
alias tgraa='terragrunt run-all apply'
alias tgrad='terragrunt run-all destroy'
alias tgrai='terragrunt run-all init'
alias tginfo='terragrunt terragrunt-info'
alias tgver='terragrunt --version'

# ==============================================================================
# AWS CLI Aliases
# ==============================================================================
alias aws-whoami='aws sts get-caller-identity'
alias aws-regions='aws ec2 describe-regions --output table'
alias aws-profiles='grep "^\[" ~/.aws/credentials 2>/dev/null | tr -d "[]"'

# EC2
alias ec2-ls='aws ec2 describe-instances --query "Reservations[*].Instances[*].{ID:InstanceId,Type:InstanceType,State:State.Name,Name:Tags[?Key==\`Name\`]|[0].Value,IP:PrivateIpAddress,PublicIP:PublicIpAddress}" --output table'
alias ec2-running='aws ec2 describe-instances --filters "Name=instance-state-name,Values=running" --query "Reservations[*].Instances[*].{ID:InstanceId,Name:Tags[?Key==\`Name\`]|[0].Value,Type:InstanceType,IP:PrivateIpAddress}" --output table'

# S3
alias s3-ls='aws s3 ls'
alias s3-buckets='aws s3api list-buckets --query "Buckets[].Name" --output table'

# EKS
alias eks-clusters='aws eks list-clusters --output table'
alias eks-update-kubeconfig='aws eks update-kubeconfig --name'

# Lambda
alias lambda-ls='aws lambda list-functions --query "Functions[].FunctionName" --output table'

# IAM
alias iam-users='aws iam list-users --query "Users[].UserName" --output table'
alias iam-roles='aws iam list-roles --query "Roles[].RoleName" --output table'

# ==============================================================================
# Azure CLI Aliases
# ==============================================================================
alias az-whoami='az account show'
alias az-accounts='az account list --output table'
alias az-subs='az account list --query "[].{Name:name,ID:id,Default:isDefault}" --output table'
alias az-set-sub='az account set --subscription'
alias az-rgs='az group list --output table'
alias az-vms='az vm list --output table'
alias az-aks='az aks list --output table'
alias az-login-sp='az login --service-principal'

# ==============================================================================
# Google Cloud Aliases
# ==============================================================================
alias gcp='gcloud'
alias gcp-whoami='gcloud config list account --format "value(core.account)"'
alias gcp-project='gcloud config get-value project'
alias gcp-projects='gcloud projects list'
alias gcp-set-project='gcloud config set project'
alias gcp-regions='gcloud compute regions list'
alias gcp-zones='gcloud compute zones list'
alias gcp-vms='gcloud compute instances list'
alias gcp-gke='gcloud container clusters list'
alias gcp-auth='gcloud auth login'
alias gcp-auth-app='gcloud auth application-default login'
alias gsutil-ls='gsutil ls'

# ==============================================================================
# OpenShift CLI Aliases
# ==============================================================================
alias oc-login='oc login'
alias oc-whoami='oc whoami'
alias oc-project='oc project'
alias oc-projects='oc projects'
alias oc-new-project='oc new-project'
alias oc-status='oc status'
alias oc-pods='oc get pods'
alias oc-svc='oc get svc'
alias oc-routes='oc get routes'
alias oc-dc='oc get dc'
alias oc-bc='oc get bc'
alias oc-logs='oc logs -f'
alias oc-rsh='oc rsh'
alias oc-console='oc whoami --show-console'

# ==============================================================================
# AWS CDK Aliases
# ==============================================================================
alias cdk-init='cdk init'
alias cdk-synth='cdk synth'
alias cdk-diff='cdk diff'
alias cdk-deploy='cdk deploy'
alias cdk-destroy='cdk destroy'
alias cdk-bootstrap='cdk bootstrap'
alias cdk-ls='cdk list'
alias cdk-doctor='cdk doctor'
alias cdk-context='cdk context'
alias cdk-ver='cdk --version'

# ==============================================================================
# Kubernetes Aliases (common across EKS/AKS/GKE/OpenShift)
# ==============================================================================
alias k='kubectl'
alias kx='kubectx'
alias kn='kubens'
alias kgp='kubectl get pods'
alias kgpa='kubectl get pods --all-namespaces'
alias kgpw='kubectl get pods -o wide'
alias kgs='kubectl get svc'
alias kgsa='kubectl get svc --all-namespaces'
alias kgd='kubectl get deployments'
alias kgn='kubectl get nodes'
alias kgno='kubectl get nodes -o wide'
alias kga='kubectl get all'
alias kgaa='kubectl get all --all-namespaces'
alias kgi='kubectl get ingress'
alias kgcm='kubectl get configmaps'
alias kgsec='kubectl get secrets'
alias kgns='kubectl get namespaces'
alias kdp='kubectl describe pod'
alias kds='kubectl describe svc'
alias kdd='kubectl describe deployment'
alias kdn='kubectl describe node'
alias kl='kubectl logs -f'
alias klp='kubectl logs -f -p'  # Previous container
alias kex='kubectl exec -it'
alias kpf='kubectl port-forward'
alias kaf='kubectl apply -f'
alias kdf='kubectl delete -f'
alias kcuc='kubectl config use-context'
alias kcgc='kubectl config get-contexts'
alias kccc='kubectl config current-context'
alias ktp='kubectl top pods'
alias ktn='kubectl top nodes'
alias krun='kubectl run -it --rm --restart=Never'
alias kdebug='kubectl run -it --rm debug --image=busybox --restart=Never -- sh'

# ==============================================================================
# Terraform Functions
# ==============================================================================

# Initialize terraform with backend config
tfinit() {
    local env="${1:-}"
    if [[ -n "$env" && -f "backend-${env}.hcl" ]]; then
        terraform init -backend-config="backend-${env}.hcl" -reconfigure
    elif [[ -n "$env" && -f "environments/${env}/backend.hcl" ]]; then
        terraform init -backend-config="environments/${env}/backend.hcl" -reconfigure
    else
        terraform init -reconfigure
    fi
}

# Plan with output file
tfplan() {
    local plan_file="${1:-tfplan}"
    terraform plan -out="$plan_file"
}

# Apply from plan file
tfapply() {
    local plan_file="${1:-tfplan}"
    if [[ -f "$plan_file" ]]; then
        terraform apply "$plan_file"
    else
        terraform apply
    fi
}

# Targeted plan/apply
tfptarget() {
    terraform plan -target="$1"
}

tfatarget() {
    terraform apply -target="$1"
}

# Format and validate
tfcheck() {
    echo "==> Formatting..."
    terraform fmt -recursive
    echo "==> Validating..."
    terraform validate
}

# Show all resources in state
tfresources() {
    terraform state list | while read -r resource; do
        echo "--- $resource ---"
        terraform state show "$resource"
        echo ""
    done
}

# Remove resource from state (useful for imports)
tfrm() {
    terraform state rm "$1"
}

# Move resource in state
tfmv() {
    terraform state mv "$1" "$2"
}

# Pull remote state
tfpull() {
    terraform state pull > terraform.tfstate.backup
    echo "State saved to terraform.tfstate.backup"
}

# Unlock state (use with caution)
tfunlock() {
    terraform force-unlock "$1"
}

# ==============================================================================
# Terragrunt Functions
# ==============================================================================

# Run terragrunt in all subdirectories
tgall() {
    terragrunt run-all "$@"
}

# Clean terragrunt cache
tgclean() {
    find . -type d -name ".terragrunt-cache" -exec rm -rf {} + 2>/dev/null
    find . -type d -name ".terraform" -exec rm -rf {} + 2>/dev/null
    echo "Cleaned .terragrunt-cache and .terraform directories"
}

# ==============================================================================
# AWS Functions
# ==============================================================================

# Switch AWS profile
aws-profile() {
    if [[ -z "$1" ]]; then
        echo "Current profile: ${AWS_PROFILE:-default}"
        echo "Available profiles:"
        grep "^\[" ~/.aws/credentials 2>/dev/null | tr -d "[]" | sed 's/^/  /'
    else
        export AWS_PROFILE="$1"
        echo "Switched to AWS profile: $AWS_PROFILE"
        aws sts get-caller-identity
    fi
}

# Assume an IAM role
aws-assume-role() {
    local role_arn="$1"
    local session_name="${2:-assumed-role-session}"
    
    if [[ -z "$role_arn" ]]; then
        echo "Usage: aws-assume-role <role-arn> [session-name]"
        return 1
    fi
    
    local creds
    creds=$(aws sts assume-role --role-arn "$role_arn" --role-session-name "$session_name" --output json)
    
    export AWS_ACCESS_KEY_ID=$(echo "$creds" | jq -r '.Credentials.AccessKeyId')
    export AWS_SECRET_ACCESS_KEY=$(echo "$creds" | jq -r '.Credentials.SecretAccessKey')
    export AWS_SESSION_TOKEN=$(echo "$creds" | jq -r '.Credentials.SessionToken')
    
    echo "Assumed role: $role_arn"
    aws sts get-caller-identity
}

# Clear assumed role credentials
aws-unassume() {
    unset AWS_ACCESS_KEY_ID
    unset AWS_SECRET_ACCESS_KEY
    unset AWS_SESSION_TOKEN
    echo "Cleared assumed role credentials"
}

# SSM session to EC2 instance
aws-ssm() {
    aws ssm start-session --target "$1"
}

# Get secret from Secrets Manager
aws-secret() {
    aws secretsmanager get-secret-value --secret-id "$1" --query 'SecretString' --output text
}

# ECR login
ecr-login() {
    local region="${1:-${AWS_DEFAULT_REGION:-us-east-1}}"
    local account
    account=$(aws sts get-caller-identity --query Account --output text)
    aws ecr get-login-password --region "$region" | docker login --username AWS --password-stdin "${account}.dkr.ecr.${region}.amazonaws.com"
}

# ==============================================================================
# Azure Functions
# ==============================================================================

# Switch Azure subscription
az-sub() {
    if [[ -z "$1" ]]; then
        az account list --query "[].{Name:name,ID:id,Default:isDefault}" --output table
    else
        az account set --subscription "$1"
        echo "Switched to subscription: $1"
        az account show
    fi
}

# Get AKS credentials
az-aks-creds() {
    local rg="$1"
    local cluster="$2"
    az aks get-credentials --resource-group "$rg" --name "$cluster" --overwrite-existing
}

# ACR login
acr-login() {
    az acr login --name "$1"
}

# ==============================================================================
# GCP Functions
# ==============================================================================

# Switch GCP project
gcp-switch() {
    if [[ -z "$1" ]]; then
        echo "Current project: $(gcloud config get-value project)"
        echo "Available projects:"
        gcloud projects list --format="value(projectId)" | sed 's/^/  /'
    else
        gcloud config set project "$1"
        echo "Switched to project: $1"
    fi
}

# Get GKE credentials
gke-creds() {
    local cluster="$1"
    local zone="${2:-}"
    local region="${3:-}"
    
    if [[ -n "$zone" ]]; then
        gcloud container clusters get-credentials "$cluster" --zone "$zone"
    elif [[ -n "$region" ]]; then
        gcloud container clusters get-credentials "$cluster" --region "$region"
    else
        echo "Usage: gke-creds <cluster-name> <zone> OR gke-creds <cluster-name> '' <region>"
    fi
}

# GCR login
gcr-login() {
    gcloud auth configure-docker
}

# ==============================================================================
# Multi-Cloud Helpers
# ==============================================================================

# Show current cloud contexts
cloud-status() {
    echo "=== AWS ==="
    if command -v aws &>/dev/null; then
        echo "Profile: ${AWS_PROFILE:-default}"
        aws sts get-caller-identity 2>/dev/null || echo "Not authenticated"
    else
        echo "AWS CLI not installed"
    fi
    
    echo ""
    echo "=== Azure ==="
    if command -v az &>/dev/null; then
        az account show --query "{Subscription:name,User:user.name}" 2>/dev/null || echo "Not authenticated"
    else
        echo "Azure CLI not installed"
    fi
    
    echo ""
    echo "=== GCP ==="
    if command -v gcloud &>/dev/null; then
        echo "Project: $(gcloud config get-value project 2>/dev/null || echo 'Not set')"
        echo "Account: $(gcloud config get-value account 2>/dev/null || echo 'Not set')"
    else
        echo "GCloud not installed"
    fi
    
    echo ""
    echo "=== Kubernetes ==="
    if command -v kubectl &>/dev/null; then
        echo "Context: $(kubectl config current-context 2>/dev/null || echo 'Not set')"
    else
        echo "kubectl not installed"
    fi
    
    echo ""
    echo "=== OpenShift ==="
    if command -v oc &>/dev/null; then
        oc whoami 2>/dev/null && oc project 2>/dev/null || echo "Not authenticated"
    else
        echo "OpenShift CLI not installed"
    fi
}

# ==============================================================================
# Completion
# ==============================================================================

# Terraform completion
if command -v terraform &>/dev/null; then
    complete -C "$(command -v terraform)" terraform
    complete -C "$(command -v terraform)" tf
fi

# AWS completion
if command -v aws_completer &>/dev/null; then
    complete -C "$(command -v aws_completer)" aws
fi

# Azure completion
if command -v az &>/dev/null; then
    source /etc/bash_completion.d/azure-cli 2>/dev/null || true
fi

# GCloud completion
if [[ -f /usr/share/google-cloud-sdk/completion.bash.inc ]]; then
    source /usr/share/google-cloud-sdk/completion.bash.inc
elif [[ -f "$HOME/google-cloud-sdk/completion.bash.inc" ]]; then
    source "$HOME/google-cloud-sdk/completion.bash.inc"
fi

# kubectl completion (already in .bashrc, but ensure it's loaded)
if command -v kubectl &>/dev/null; then
    source <(kubectl completion bash 2>/dev/null)
fi

# oc completion
if command -v oc &>/dev/null; then
    source <(oc completion bash 2>/dev/null)
fi

echo "ðŸ”§ Terraform/IaC environment loaded"
